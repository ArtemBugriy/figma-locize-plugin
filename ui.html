<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Locize Integration</title>
<style>
  /* Narrow scrollbar */
  ::-webkit-scrollbar { width: 3px; height: 3px; background: transparent; }
  ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 1.5px; }
  ::-webkit-scrollbar-thumb:hover { background: #999; }
  ::-webkit-scrollbar-track { background: transparent; border-radius: 1.5px; }
  /* Base styles */
  body { font: 12px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 12px; }
  h2 { margin: 8px 0 4px; font-size: 14px; }
  fieldset { border: 1px solid #ccc; padding: 8px 10px 10px; margin-bottom: 10px; }
  legend { padding: 0 4px; font-weight: 600; }
  label { display: flex; flex-direction: column; font-size: 11px; gap: 2px; }
  input[type=text], input[type=password], select { padding: 4px 6px; font-size: 12px; }
  input.key-input { width: 220px; }
  table { border-collapse: collapse; width: 100%; font-size: 11px; }
  th, td { border: 1px solid #ddd; padding: 4px 6px; vertical-align: top; }
  th { background: #f5f5f5; position: sticky; top: 0; }
  /* keep old statuses for sync coloring */
  tbody tr.synced td { background: #f0fff4; }
  tbody tr.unsynced td { background: #fff8db; }
  tbody tr.missing td { background: #fff7f7; }
  tbody input { border: none; outline: none; background: transparent; }
  .actions { display: flex; gap: 8px; flex-wrap: wrap; }
  button { cursor: pointer; padding: 4px 12px; font-size: 12px; }
  .row-flex { display: flex; gap: 8px; }
  .small { font-size: 10px; color: #666; }
  .status { margin-top: 6px; min-height: 16px; font-size: 11px; white-space: pre-line; }
  .lang-badge { background:#eee; padding:2px 6px; border-radius:10px; font-size:10px; margin-right:4px; display:inline-block; }
  .flex { display: flex; }
  .gap { gap: 8px; }
  .grow { flex: 1; }
  .nowrap { white-space: nowrap; }
  #keys-container { max-height: 600px; overflow: auto; }
  #uploadProgress { width: 100%; height: 4px; background: #eee; margin-top:4px; position: relative; }
  #uploadProgress span { position:absolute; top:0; left:0; height:100%; background:#4a8cff; width:0; transition: width .2s; }
  /* Active mode styling for Scan selection button */
  #scanSelection.active { background: #4a8cff; color: #fff; border-color: #4a8cff; }
  #scanSelection.active:hover { background: #3a74d1; }
</style>
</head>
<body>
  <fieldset>
    <legend>Settings</legend>
    <div class="row-flex" style="align-items:flex-end; flex-wrap:wrap;">
      <label class="grow">Project ID<input id="projectId" type="text" placeholder="project id" /></label>
      <label class="grow">API Key (write)<input id="apiKey" type="password" placeholder="write api key" /></label>
      <label>Version<input id="version" type="text" value="latest" /></label>
      <label>Base Lang<input id="baseLanguage" type="text" value="en" /></label>
      <button id="saveSettings">Save</button>
    </div>
    <div class="small" style="margin-top: 12px;">Data is saved locally in the plugin clientStorage.</div>
  </fieldset>

  <fieldset>
    <legend>Language</legend>
    <div class="row-flex gap" style="align-items:center; flex-wrap:wrap;">
      <label>Language<select id="languageSelect"></select></label>
    </div>
    <div class="small">Namespaces are detected automatically from existing keys. If no keys are assigned, loading is skipped.</div>
    <div class="small" id="nsListInfo" style="margin-top:4px;color:#444;"></div>
  </fieldset>

  <fieldset>
    <legend>Key management</legend>
    <div class="row-flex gap" style="align-items:flex-end; flex-wrap:wrap;">
      <label>Namespace for new keys<input id="scanNamespace" type="text" placeholder="Common" /></label>
      <div class="row-flex" style="align-items:center; gap:6px;">
        <button id="scanSelection">Scan selection</button>
      </div>
      <label style="flex-direction:row; align-items:center; gap:6px; margin:0;">
        <input id="hideUnchecked" type="checkbox" />
        <span>Hide unchecked</span>
      </label>
      <label class="grow">Suggest from namespaces (comma separated)
        <input id="suggestNamespaces" type="text" placeholder="Common, Landing, Auth" />
      </label>
      <button id="suggestKeys">Suggest keys</button>
      <!-- New: Apply all top suggestions button -->
      <button id="applyTopSuggestions" title="Apply first suggestion for each selected row (or all if none selected)">Apply all top suggestions</button>
    </div>
    <div class="small" style="margin: 6px 0;">Keys are generated based on hierarchy and layer/text name.</div>
    <div id="keys-container">
      <table id="keysTable">
        <thead>
          <tr>
            <th><input type="checkbox" id="selectAll" aria-label="Select all" /></th>
            <th><small>✏️</small>&nbsp;Namespace</th>
            <th><small>✏️</small>&nbsp;Key</th>
            <th style="min-width: 150px;"><small>✏️</small>&nbsp;Text</th>
            <th style="min-width: 150px;">Remote Text</th>
            <th>Suggestions</th>
            <th>Original Node Name</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="actions" style="margin-top:6px;">
      <button id="applyKeys" disabled>Apply keys to nodes</button>
      <button id="uploadKeys" disabled>Upload to locize</button>
      <label style="flex-direction:row; align-items:center; gap:6px; margin:0;" title="Available only for base language">
        <input id="autotranslate" type="checkbox" />
        <span>Autotranslate</span>
      </label>
      <button id="restoreNames" disabled>Restore original node names</button>
    </div>
    <div id="uploadProgress"><span></span></div>
  </fieldset>

  <div class="status" id="status"></div>

<script>
const els = {
  projectId: document.getElementById('projectId'),
  apiKey: document.getElementById('apiKey'),
  version: document.getElementById('version'),
  baseLanguage: document.getElementById('baseLanguage'),
  scanNamespace: document.getElementById('scanNamespace'),
  saveSettings: document.getElementById('saveSettings'),
  scanSelection: document.getElementById('scanSelection'),
  applyKeys: document.getElementById('applyKeys'),
  uploadKeys: document.getElementById('uploadKeys'),
  status: document.getElementById('status'),
  tableBody: document.querySelector('#keysTable tbody'),
  selectAll: document.getElementById('selectAll'),
  languageSelect: document.getElementById('languageSelect'),
  uploadProgress: document.querySelector('#uploadProgress span'),
  restoreNames: document.getElementById('restoreNames'),
  nsListInfo: document.getElementById('nsListInfo'),
  hideUnchecked: document.getElementById('hideUnchecked'),
  autotranslate: document.getElementById('autotranslate'),
  suggestNamespaces: document.getElementById('suggestNamespaces'),
  suggestKeys: document.getElementById('suggestKeys'),
  // New: bulk apply top suggestions button
  applyTopSuggestions: document.getElementById('applyTopSuggestions'),
};

let currentItems = [];
let detectedNamespaces = [];
let hideUnchecked = false;
let currentLanguage = '';

// Track verification sequence and allow cancellation
let verifyController = null; // AbortController | null
let verifySeq = 0;

// Cache of translations by language and namespace: { [language]: { [ns]: flatMap } }
const remoteCache = {};
// Suggestion candidates pool by language
const suggestionPool = {};
// Max suggestions per item
const SUGGESTIONS_MAX = 5;

function pm(message){ parent.postMessage({ pluginMessage: message }, '*'); }
function setStatus(msg, append=false){ if(!append) els.status.textContent=''; els.status.textContent += msg + '\n'; }

// Enable/disable autotranslate checkbox depending on selected vs base language
function updateAutotranslateAvailability(){
  const s = collectSettings();
  const lang = els.languageSelect.value || s.baseLanguage || 'en';
  const isBase = lang === (s.baseLanguage || 'en');
  if (els.autotranslate) {
    els.autotranslate.disabled = !isBase;
    const label = els.autotranslate.closest('label');
    if(label) label.style.opacity = isBase ? '' : '0.6';
    els.autotranslate.title = isBase ? '' : 'Works only for base language';
  }
}

function renderTable(){
  els.tableBody.innerHTML = '';
  const itemsToRender = hideUnchecked ? currentItems.filter(i => i.selected !== false) : currentItems;
  itemsToRender.forEach((item) => {
    if(!item.namespace || !item.localKey){
      const dot = (item.key||'').indexOf('.')
      if(dot>-1){ item.namespace = item.key.slice(0,dot); item.localKey = item.key.slice(dot+1); } else { item.namespace = ''; item.localKey = item.key; }
    }
    const tr = document.createElement('tr');
    const statusClass = item.status || (item.synced === true ? 'synced' : (item.synced === false ? 'unsynced' : ''));
    tr.className = statusClass;

    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = item.selected !== false;
    cb.addEventListener('change', () => { item.selected = cb.checked; updateButtons(); pm({ type: 'set-selected', nodeId: item.nodeId, selected: item.selected }); if(hideUnchecked) renderTable(); });
    tdSel.appendChild(cb);

    const tdNs = document.createElement('td');
    const nsInput = document.createElement('input');
    nsInput.type = 'text';
    nsInput.value = item.namespace || '';
    nsInput.style.width = '90px';
    // Сохраняем начальное значение на фокус
    nsInput.addEventListener('focus', () => { nsInput.dataset.prev = item.namespace || ''; });
    // Обновляем модель на ввод, но не триггерим перерасчёты/перерисовку
    nsInput.addEventListener('input', () => { item.namespace = nsInput.value; /* no recompute/render here */ });
    // Применяем изменения только на blur/Enter
    const commitNs = () => {
      const val = (nsInput.value || '').trim();
      nsInput.value = val;
      item.namespace = val;
      recomputeKey(item);
      scheduleStatusRefresh();
      scheduleSuggestionsRefresh();
    };
    nsInput.addEventListener('blur', commitNs);
    nsInput.addEventListener('keydown', (e) => {
      if(e.key === 'Enter'){ e.preventDefault(); nsInput.blur(); }
      if(e.key === 'Escape'){ e.preventDefault(); nsInput.value = nsInput.dataset.prev || ''; nsInput.blur(); }
    });
    tdNs.appendChild(nsInput);

    const tdKey = document.createElement('td');
    const keyInput = document.createElement('input');
    keyInput.type = 'text';
    keyInput.value = item.localKey || '';
    keyInput.className = 'key-input';
    // Сохраняем начальное значение на фокус
    keyInput.addEventListener('focus', () => { keyInput.dataset.prev = item.localKey || ''; });
    // Только локально обновляем модель
    keyInput.addEventListener('input', () => { item.localKey = keyInput.value; /* no recompute/render here */ });
    const commitKey = () => {
      const val = (keyInput.value || '').trim();
      keyInput.value = val;
      item.localKey = val;
      recomputeKey(item);
      scheduleStatusRefresh();
      scheduleSuggestionsRefresh();
    };
    keyInput.addEventListener('blur', commitKey);
    keyInput.addEventListener('keydown', (e) => {
      if(e.key === 'Enter'){ e.preventDefault(); keyInput.blur(); }
      if(e.key === 'Escape'){ e.preventDefault(); keyInput.value = keyInput.dataset.prev || ''; keyInput.blur(); }
    });
    tdKey.appendChild(keyInput);

    const tdText = document.createElement('td');
    // Editable text with apply-on-blur sync to node (contenteditable)
    const textDiv = document.createElement('div');
    textDiv.contentEditable = 'true';
    textDiv.textContent = item.text ?? '';
    textDiv.style.width = '100%';
    textDiv.style.boxSizing = 'border-box';
    textDiv.style.minHeight = '22px';
    textDiv.style.whiteSpace = 'pre-wrap';
    textDiv.style.wordBreak = 'break-word';
    textDiv.style.outline = 'none';
    textDiv.addEventListener('input', () => {
      // Обновляем только локальное значение, без перерисовки/статуса во время набора
      item.text = textDiv.innerText;
      // Не отправляем в Figma и не обновляем статус/подсказки на каждый символ
    });
    textDiv.addEventListener('blur', () => {
      // Применяем в Figma и обновляем статус/подсказки только при потере фокуса
      const val = textDiv.innerText;
      item.text = val;
      pm({ type: 'update-text', nodeId: item.nodeId, text: val });
      scheduleStatusRefresh();
      scheduleSuggestionsRefresh();
    });
    // Paste as plain text only
    textDiv.addEventListener('paste', (e) => {
      try {
        e.preventDefault();
      } catch(_) {}
      const pe = e;
      const txt = (pe.clipboardData && pe.clipboardData.getData('text/plain')) || '';
      // execCommand is deprecated, but supported in plugin iframe environment
      try { document.execCommand('insertText', false, txt); }
      catch(_) {
        // Fallback: replace content
        const sel = window.getSelection();
        if (sel && sel.rangeCount) {
          sel.deleteFromDocument();
          sel.getRangeAt(0).insertNode(document.createTextNode(txt));
        } else {
          textDiv.textContent = (textDiv.textContent || '') + txt;
        }
      }
    });
    tdText.appendChild(textDiv);

    const tdRemote = document.createElement('td');
    tdRemote.textContent = item.remoteText ?? '';

    const tdSugg = document.createElement('td');
    if(Array.isArray(item.suggestions) && item.suggestions.length){
      const select = document.createElement('select');
      item.suggestions.forEach((sug, idx) => {
        const opt = document.createElement('option');
        opt.value = `${sug.namespace}.${sug.key}`;
        // Показываем превью значения, чтобы удобнее выбирать
        const preview = (sug.value || '').replace(/\s+/g,' ').slice(0,60);
        opt.textContent = `${sug.namespace}.${sug.key}${preview ? ' — '+preview : ''}`;
        if(idx===0) opt.selected = true;
        select.appendChild(opt);
      });
      const applyBtn = document.createElement('button');
      applyBtn.textContent = 'Apply';
      applyBtn.addEventListener('click', () => {
        const val = select.value;
        const dot = val.indexOf('.');
        const ns = dot>-1 ? val.slice(0,dot) : '';
        const lk = dot>-1 ? val.slice(dot+1) : val;
        item.namespace = ns; item.localKey = lk; recomputeKey(item);
        // keep selected on, do not auto-apply to nodes
        item.selected = item.selected !== false;
        renderTable();
        scheduleStatusRefresh();
      });
      tdSugg.appendChild(select);
      tdSugg.appendChild(applyBtn);
    } else {
      tdSugg.textContent = '—';
    }

    const tdOrig = document.createElement('td');
    tdOrig.textContent = item.originalName || '';

    const tdStatus = document.createElement('td');
    const statusText = item.status ? item.status : (item.synced === true ? 'synced' : (item.synced === false ? 'unsynced' : '—'));
    tdStatus.textContent = statusText;

    tr.appendChild(tdSel); tr.appendChild(tdNs); tr.appendChild(tdKey); tr.appendChild(tdText); tr.appendChild(tdRemote); tr.appendChild(tdSugg); tr.appendChild(tdOrig); tr.appendChild(tdStatus);
    els.tableBody.appendChild(tr);
  });
  updateButtons();
}

function recomputeKey(item){
  const ns = (item.namespace||'').trim();
  const lk = (item.localKey||'').trim();
  item.key = ns ? `${ns}.${lk}` : lk;
}

function updateButtons(){
  const all = currentItems.length > 0 && currentItems.every(i => i.selected !== false);
  const none = currentItems.every(i => i.selected === false);
  els.selectAll.indeterminate = !all && !none;
  els.selectAll.checked = all && !none;

  const anySelected = currentItems.some(i => i.selected !== false);
  els.applyKeys.disabled = !anySelected;
  els.uploadKeys.disabled = !anySelected;
  els.restoreNames.disabled = !currentItems.length;
  // New: enable bulk apply if we have any items
  if (els.applyTopSuggestions) els.applyTopSuggestions.disabled = !currentItems.length;
}

// New: flatten nested dict to flat map of key -> value
function flattenToMap(obj){
  const out = {};
  const stack = [[obj, '']];
  while(stack.length){
    const [cur, pref] = stack.pop();
    if(cur && typeof cur === 'object' && !Array.isArray(cur)){
      for(const k of Object.keys(cur)){
        const v = cur[k];
        const p = pref ? pref + '.' + k : k;
        if(v && typeof v === 'object' && !Array.isArray(v)) stack.push([v, p]);
        else out[p] = typeof v === 'string' ? v : (v != null ? String(v) : '');
      }
    } else {
      if(pref) out[pref] = typeof cur === 'string' ? cur : (cur != null ? String(cur) : '');
    }
  }
  return out;
}

let statusRefreshTimer = null;
function scheduleStatusRefresh(){
  clearTimeout(statusRefreshTimer);
  statusRefreshTimer = setTimeout(() => refreshSyncStatus(), 400);
}

async function refreshSyncStatus(){
  const s = collectSettings();
  if(!currentLanguage){ currentLanguage = els.languageSelect.value || s.baseLanguage || 'en'; }
  const nsSet = Array.from(new Set(currentItems.map(i => (i.namespace||'').trim()).filter(Boolean)));
  if(!nsSet.length){ currentItems.forEach(i=>{ i.synced=undefined; i.remoteText=undefined; i.status=undefined; }); renderTable(); return; }
  try {
    const baseLang = s.baseLanguage || 'en';
    // Ensure cache for required namespaces for current and base languages
    for(const ns of nsSet){
      if(!remoteCache[currentLanguage]) remoteCache[currentLanguage] = {};
      if(!remoteCache[currentLanguage][ns]){
        const data = await fetchTranslations(s, currentLanguage, ns);
        remoteCache[currentLanguage][ns] = flattenToMap(data);
      }
      if(!remoteCache[baseLang]) remoteCache[baseLang] = {};
      if(!remoteCache[baseLang][ns]){
        const baseData = await fetchTranslations(s, baseLang, ns);
        remoteCache[baseLang][ns] = flattenToMap(baseData);
      }
    }
    // Update items synced state using currentLanguage and baseLanguage translations
    currentItems.forEach(item => {
      const ns = (item.namespace||'').trim();
      const lk = (item.localKey||'').trim();
      if(!ns || !lk){ item.synced = undefined; item.remoteText = undefined; item.status = undefined; return; }
      const curMap = (remoteCache[currentLanguage] || {})[ns] || {};
      const baseMap = (remoteCache[s.baseLanguage || 'en'] || {})[ns] || {};
      const hasRemote = Object.prototype.hasOwnProperty.call(curMap, lk);
      const hasBase = Object.prototype.hasOwnProperty.call(baseMap, lk);
      const remote = hasRemote ? curMap[lk] : undefined;
      item.remoteText = remote;
      const local = String(item.text ?? '');

      if(currentLanguage !== (s.baseLanguage || 'en')){
        if(!hasBase && !hasRemote){
          item.status = 'missing';
          item.synced = false;
        } else if(hasBase && !hasRemote){
          item.status = 'unsynced';
          item.synced = false;
        } else {
          const remoteStr = String(remote ?? '');
          const equal = local === remoteStr;
          if(remoteStr === '' || !equal){
            item.status = 'unsynced';
            item.synced = false;
          } else {
            item.status = 'synced';
            item.synced = true;
          }
        }
      } else {
        // current language is base language
        if(!hasRemote){
          item.status = 'missing';
          item.synced = false;
        } else {
          const remoteStr = String(remote ?? '');
          const equal = local === remoteStr;
          if(remoteStr === '' || !equal){
            item.status = 'unsynced';
            item.synced = false;
          } else {
            item.status = 'synced';
            item.synced = true;
          }
        }
      }
    });
  } catch(e){
    setStatus('Status check failed: '+ (e && e.message ? e.message : e));
    currentItems.forEach(i=>{ i.synced=undefined; i.remoteText=undefined; i.status=undefined; });
  }
  renderTable();
}

// Settings load
pm({ type: 'load-settings' });

els.saveSettings.addEventListener('click', async () => {
  const s = collectSettings();
  if(!validateSettings(s)) { pm({ type:'notify', message:'ProjectId and ApiKey are required' }); return; }
  if(verifyController) { try { verifyController.abort(); } catch(_){} }
  verifyController = new AbortController();
  const seq = ++verifySeq;
  els.saveSettings.disabled = true;
  const ok = await verifyCredentials(s, verifyController.signal, seq);
  if(seq !== verifySeq) { return; }
  els.saveSettings.disabled = false;
  if(ok){
    pm({ type: 'save-settings', settings: s });
    if(!els.scanNamespace.value) els.scanNamespace.value = 'Common';
    fetchLanguagesList();
    pm({ type: 'get-namespaces' });
    scheduleStatusRefresh();
    updateAutotranslateAvailability();
  } else {
    pm({ type:'notify', message:'Invalid Locize credentials' });
  }
});

function collectSettings(){
  return {
    projectId: els.projectId.value.trim(),
    apiKey: els.apiKey.value.trim(),
    version: els.version.value.trim() || 'latest',
    baseLanguage: els.baseLanguage.value.trim() || 'en',
  };
}

els.scanSelection.addEventListener('click', () => {
  if (lastMode === 'scan') {
    lastMode = null;
    reflectMode();
    setStatus('Scan mode off');
    return;
  }
  lastMode = 'scan';
  reflectMode();
  const ns = (els.scanNamespace.value || 'Common').trim();
  pm({ type: 'scan-selection', namespace: ns });
});

els.hideUnchecked.addEventListener('change', () => {
  hideUnchecked = els.hideUnchecked.checked;
  renderTable();
});

els.applyKeys.addEventListener('click', () => {
  const items = currentItems.filter(i => i.selected !== false).map(i => ({ ...i }));
  pm({ type: 'apply-keys', items });
  scheduleStatusRefresh();
});

els.uploadKeys.addEventListener('click', async () => {
  const sel = currentItems.filter(i => i.selected !== false);
  if(!sel.length) return;
  const s = collectSettings();
  if(!validateSettings(s)) return;
  await uploadSelectedKeys(sel, s);
  // Invalidate all caches (both languages)
  for(const k in remoteCache) delete remoteCache[k];
  await refreshSyncStatus();
});

els.selectAll.addEventListener('change', () => {
  currentItems.forEach(i => i.selected = els.selectAll.checked);
  pm({ type: 'set-selected-bulk', list: currentItems.map(i => ({ nodeId: i.nodeId, selected: i.selected !== false })) });
  renderTable();
});

// Parse comma separated namespaces
function parseSuggestNamespaces(){
  const raw = (els.suggestNamespaces?.value || '').trim();
  if(!raw) return [];
  return raw.split(',').map(s=>s.trim()).filter(Boolean);
}

// Normalize string for fuzzy
function normalizeVal(v){
  return String(v ?? '')
    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .trim();
}

// Доп. нормализация для ключей (ns.key) и разбиение на токены
function normalizeKey(k){
  const s = String(k ?? '')
    .replace(/([a-z])([A-Z])/g, '$1 $2') // split camelCase
    .replace(/[._-]+/g, ' ');
  return normalizeVal(s);
}

// Build candidates pool for language+namespaces
function buildSuggestionPool(language, namespaces){
  const pool = [];
  for(const ns of namespaces){
    const flat = ((remoteCache[language]||{})[ns]) || {};
    for(const key of Object.keys(flat)){
      const val = String(flat[key] || '');
      if(!val) continue;
      const norm = normalizeVal(val);
      const tokens = norm.split(' ');
      const fullKey = `${ns}.${key}`;
      const normKey = normalizeKey(fullKey);
      const keyTokens = normKey.split(' ');
      pool.push({ namespace: ns, key, value: val, norm, tokens, fullKey, normKey, keyTokens });
    }
  }
  suggestionPool[language] = pool;
}

// Ensure dictionaries for suggestion namespaces are loaded, then build pool
async function ensureSuggestNamespacesLoaded(s, language, namespaces){
  if(!remoteCache[language]) remoteCache[language] = {};
  for(const ns of namespaces){
    if(!remoteCache[language][ns]){
      try {
        const translations = await fetchTranslations(s, language, ns);
        remoteCache[language][ns] = flattenToMap(translations);
      } catch(e){ setStatus(`Suggest preload failed for ${ns}: ${e && e.message ? e.message : e}`, true); }
    }
  }
  buildSuggestionPool(language, namespaces);
}

// Базовый скоринг между нормализованной строкой запроса и нормализованным кандидатом
function baseFuzzyScore(queryNorm, candNorm, candTokens){
  if(!queryNorm || !candNorm) return 0;
  if(queryNorm === candNorm) return 1.0;
  let score = 0;
  // substring based
  if(candNorm.includes(queryNorm)){
    const ratio = Math.min(1, queryNorm.length / Math.max(1, candNorm.length));
    score = Math.max(score, 0.85 * ratio);
  }
  if(queryNorm.includes(candNorm)){
    const ratio = Math.min(1, candNorm.length / Math.max(1, queryNorm.length));
    score = Math.max(score, 0.75 * ratio);
  }
  // token overlap
  const qTokens = queryNorm.split(' ');
  const setQ = new Set(qTokens);
  let overlap = 0;
  for(const t of candTokens){ if(setQ.has(t)) overlap++; }
  if(qTokens.length){
    const tokenRatio = overlap / Math.max(qTokens.length, candTokens.length);
    score = Math.max(score, 0.7 * tokenRatio);
  }
  return score;
}

// Вычисление комбинированного скоринга: по тексту и по ключу
function combinedScore(valueQueryNorm, keyQueryNorm, cand){
  const sVal = baseFuzzyScore(valueQueryNorm, cand.norm, cand.tokens);
  const sKey = baseFuzzyScore(keyQueryNorm, cand.normKey, cand.keyTokens);
  // Небольшой бонус, если namespace совпадает с выбранным у айтема
  return Math.max(sVal, sKey * 0.95);
}

// Compute suggestions for each item
function suggestForItems(language, namespaces, limit=5, threshold=0.3){
  const pool = suggestionPool[language] || [];
  for(const item of currentItems){
    const valueQuery = normalizeVal(item.text);
    const keyQuery = normalizeKey(item.localKey || '');
    const list = [];
    if(valueQuery || keyQuery){
      for(const cand of pool){
        const s = combinedScore(valueQuery, keyQuery, cand);
        if(s >= threshold){ list.push({ namespace: cand.namespace, key: cand.key, value: cand.value, score: s }); }
      }
      list.sort((a,b)=> b.score - a.score);
      const cap = Math.min(SUGGESTIONS_MAX, Number.isFinite(limit) ? limit : SUGGESTIONS_MAX);
      item.suggestions = list.slice(0, cap);
    } else {
      item.suggestions = [];
    }
  }
}

let suggestionsRefreshTimer = null;
function scheduleSuggestionsRefresh(){
  clearTimeout(suggestionsRefreshTimer);
  suggestionsRefreshTimer = setTimeout(() => { updateSuggestionsForCurrent(); }, 250);
}

async function updateSuggestionsForCurrent(){
  const s = collectSettings();
  const lang = els.languageSelect.value || s.baseLanguage || 'en';
  const nsList = parseSuggestNamespaces();
  if(!nsList.length){ currentItems.forEach(i => i.suggestions = []); renderTable(); return; }
  await ensureSuggestNamespacesLoaded(s, lang, nsList);
  suggestForItems(lang, nsList);
  renderTable();
}

els.languageSelect.addEventListener('change', async () => {
  const s = collectSettings(); if(!s.projectId || !s.version){ setStatus('Fill in settings'); return; }
  const lang = els.languageSelect.value; if(!lang) { setStatus('Select a language'); return; }
  currentLanguage = lang;
  updateAutotranslateAvailability();
  if(!detectedNamespaces.length){ setStatus('No saved keys (namespaces list is empty)'); return; }
  setStatus('Loading translations for: '+ detectedNamespaces.join(', '), false);
  const sTime = Date.now();
  // clear caches for new selection
  for(const k in remoteCache) delete remoteCache[k];
  const baseLang = s.baseLanguage || 'en';
  for(const ns of detectedNamespaces){
    try {
      setStatus('→ '+ns+' ...', true);
      const translations = await fetchTranslations(s, lang, ns);
      const flatMap = flattenToMap(translations);
      if(!remoteCache[lang]) remoteCache[lang] = {};
      remoteCache[lang][ns] = flatMap;
      pm({ type: 'apply-language', map: flatMap, namespace: ns });
      if(baseLang !== lang){
        const baseTranslations = await fetchTranslations(s, baseLang, ns);
        const baseFlat = flattenToMap(baseTranslations);
        if(!remoteCache[baseLang]) remoteCache[baseLang] = {};
        remoteCache[baseLang][ns] = baseFlat;
      }
      setStatus('✓ '+ns, true);
    } catch(e){ setStatus('✗ '+ns+': '+ (e && e.message ? e.message : e), true); }
  }
  // Ask Figma to return current assigned items (to refresh node texts)
  pm({ type: 'get-assigned' });
  await refreshSyncStatus();
  setStatus('Done in '+ ((Date.now()-sTime)/1000).toFixed(1)+'s', true);
  // update suggestions if namespaces provided
  updateSuggestionsForCurrent();
});

els.restoreNames.addEventListener('click', () => {
  const selected = currentItems.filter(i => i.selected !== false);
  const targets = selected.length ? selected : currentItems;
  pm({ type: 'restore-names', items: targets.map(t => ({ nodeId: t.nodeId })) });
  setStatus('Restoring names...');
});

// New: apply all top suggestions (selected rows, or all if none selected)
els.applyTopSuggestions?.addEventListener('click', async () => {
  await updateSuggestionsForCurrent();
  const selected = currentItems.filter(i => i.selected !== false);
  const targets = selected.length ? selected : currentItems;
  let applied = 0, skipped = 0;
  for(const item of targets){
    const sug = Array.isArray(item.suggestions) && item.suggestions[0];
    if(sug){
      item.namespace = sug.namespace;
      item.localKey = sug.key;
      recomputeKey(item);
      // keep selected on, do not auto-apply to nodes
      item.selected = item.selected !== false;
      applied++;
    } else {
      skipped++;
    }
  }
  renderTable();
  scheduleStatusRefresh();
  setStatus(`Applied top suggestions: ${applied}${skipped ? `, skipped: ${skipped}` : ''}`);
});

function validateSettings(s){
  if(!s.projectId || !s.apiKey){ setStatus('ProjectId and ApiKey are required'); return false; }
  return true;
}

async function fetchLanguagesList(){
  const s = collectSettings(); if(!s.projectId) return;
  try {
    const res = await fetch(`https://api.locize.app/languages/${s.projectId}`);
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data = await res.json();
    const langs = Object.keys(data);
    els.languageSelect.innerHTML = langs.map(l => `<option value="${l}">${l}</option>`).join('');
    if(s.baseLanguage && !els.languageSelect.value) els.languageSelect.value = s.baseLanguage;
    updateAutotranslateAvailability();
  } catch(e){ setStatus('Failed to load languages: '+ e.message); }
}

async function fetchTranslations(s, language, namespace){
  const ns = encodeURIComponent(namespace);
  const url = `https://api.locize.app/${s.projectId}/${s.version}/${language}/${ns}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  return res.json();
}

async function uploadSelectedKeys(items, s){
  const lang = els.languageSelect.value || s.baseLanguage || 'en';
  const isBase = lang === (s.baseLanguage || 'en');
  const doAutotranslate = isBase && !!(els.autotranslate && els.autotranslate.checked);
  // group by namespace
  const byNs = new Map();
  for(const it of items){
    const ns = (it.namespace || 'Common').trim();
    const local = (it.localKey || (it.key||'').replace(/^.*\./,'')).trim();
    if(!ns || !local){ setStatus('Skip item with empty namespace/localKey: '+ (it.key||'?'), true); continue; }
    if(!byNs.has(ns)) byNs.set(ns, []);
    byNs.get(ns).push({ key: local, value: String(it.text ?? '') });
  }
  const totalKeys = Array.from(byNs.values()).reduce((acc, arr) => acc + arr.length, 0);
  if(totalKeys === 0){ setStatus('Nothing to upload'); return; }

  setStatus(`Uploading keys to ${lang} (bulk update)${doAutotranslate ? ' [autotranslate]' : ''}...`);
  let sentKeys = 0;
  setProgress(0);
  for(const [ns, entries] of byNs.entries()){
    setStatus(`Namespace ${ns}: ${entries.length} key(s)` , true);
    // chunk to 1000 keys per request
    for(const chunk of chunkArray(entries, 1000)){
      const payload = {};
      for(const {key, value} of chunk){ payload[key] = value; }
      try {
        const resInfo = await updateTranslationsBatch(s, lang, ns, payload, doAutotranslate);
        sentKeys += chunk.length;
        setProgress(sentKeys/totalKeys*100);
        const note = resInfo?.note ? ` (${resInfo.note})` : '';
        setStatus(`✓ ${ns}: +${chunk.length} translations${note}`, true);
      } catch(e){
        setStatus(`✗ ${ns}: ${e && e.message ? e.message : e}`, true);
      }
    }
  }
  // Invalidate and refresh cache for current language
  for(const k in remoteCache) delete remoteCache[k];
  await refreshSyncStatus();
  setStatus(`Done. Uploaded: ${sentKeys}/${totalKeys}`, true);
}

function setProgress(percent){
  els.uploadProgress.style.width = percent.toFixed(2) + '%';
}

function chunkArray(arr, size){
  const out = [];
  for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i, i+size));
  return out;
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function fetchWithAuth(url, options, apiKey){
  // Prefer Bearer as in docs, fallback to raw on 401/403
  let res = await fetch(url, { ...options, headers: { ...(options.headers||{}), Authorization: `Bearer ${apiKey}` } });
  if ((res.status === 401 || res.status === 403) && !String(apiKey||'').startsWith('Bearer ')){
    res = await fetch(url, { ...options, headers: { ...(options.headers||{}), Authorization: apiKey } });
  }
  return res;
}

async function updateTranslationsBatch(s, language, namespace, body, autotranslate=false){
  const ns = encodeURIComponent(namespace || 'Common');
  const q = autotranslate ? '?autotranslate=true' : '';
  const url = `https://api.locize.app/update/${s.projectId}/${s.version}/${language}/${ns}${q}`;
  const opts = {
    method: 'POST',
    headers: { 'Content-Type':'application/json', 'Accept':'application/json' },
    body: JSON.stringify(body)
  };

  // retry on 429 with small backoff
  const maxRetries = 2;
  for(let attempt=0; attempt<=maxRetries; attempt++){
    const res = await fetchWithAuth(url, opts, s.apiKey);
    if(res.status === 429 && attempt < maxRetries){
      await sleep(250 * (attempt+1));
      continue;
    }
    if(res.status === 412){
      // nothing changed, treat as success
      return { ok: true, note: 'no changes' };
    }
    if(!res.ok){
      let extra = '';
      try { extra = await res.text(); } catch(_) {}
      throw new Error(`HTTP ${res.status}${extra ? ': '+extra : ''}`);
    }
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) {
      try { return await res.json(); } catch(_) { return { ok: true }; }
    }
    return { ok: true };
  }
}

function isObjectEmpty(obj){
  if(!obj || typeof obj !== 'object') return true;
  return Object.keys(obj).length === 0;
}

async function verifyCredentials(s, signal, seq){
  const isCurrent = () => seq === verifySeq;
  if(isCurrent()) setStatus('Verifying credentials...');
  try {
    const res = await fetch(`https://api.locize.app/languages/${s.projectId}`, { signal });
    const json = await res.json();
    if (isObjectEmpty(json)) { if(isCurrent()) setStatus('Project is empty or not found', true); return false; }
    if(res.status === 404){ if(isCurrent()) setStatus('Project not found (404)', true); return false; }
    if(res.status === 401 || res.status === 403){ if(isCurrent()) setStatus('Unauthorized to access project: '+res.status, true); return false; }
    if(!res.ok){ if(isCurrent()) setStatus('Project check failed: HTTP '+res.status, true); return false; }
    if(isCurrent()) setStatus('Credentials verified ✓', true);
    return true;
  } catch(e){ if(signal?.aborted) { return false; } if(isCurrent()) setStatus('Project check failed: '+ (e && e.message ? e.message : e), true); return false; }
}

window.onmessage = (event) => {
  const msg = event.data.pluginMessage;
  if(!msg) return;
  switch(msg.type){
    case 'settings-loaded': {
      const s = msg.settings;
      els.projectId.value = s.projectId || '';
      els.apiKey.value = s.apiKey || '';
      els.version.value = s.version || 'latest';
      els.baseLanguage.value = s.baseLanguage || 'en';
      if(!els.scanNamespace.value) els.scanNamespace.value = 'Common';
      fetchLanguagesList();
      pm({ type: 'get-namespaces' });
      scheduleStatusRefresh();
      updateAutotranslateAvailability();
      break;
    }
    case 'scan-result': {
      if(msg.warning) setStatus(msg.warning);
      currentItems = (msg.items || []).map(it => ({ ...it, selected: it.selected !== false, synced: undefined, remoteText: undefined, status: undefined }));
      renderTable();
      pm({ type: 'get-namespaces' });
      scheduleStatusRefresh();
      // update suggestions if namespaces provided
      updateSuggestionsForCurrent();
      break;
    }
    case 'assigned-result': {
      const incoming = Array.isArray(msg.items) ? msg.items : [];
      const curMap = new Map(currentItems.map(it => [it.nodeId, it]));
      for(const inc of incoming){
        const existing = curMap.get(inc.nodeId);
        if(existing){
          existing.text = inc.text;
          existing.name = inc.name;
          existing.originalName = inc.originalName || existing.originalName;
          existing.key = inc.key;
          existing.namespace = inc.namespace;
          existing.localKey = inc.localKey;
          existing.existing = true;
        } else {
          curMap.set(inc.nodeId, { ...inc, selected: inc.selected !== false, synced: undefined, remoteText: undefined, status: undefined });
        }
      }
      currentItems = Array.from(curMap.values());
      renderTable();
      scheduleStatusRefresh();
      // update suggestions if namespaces provided
      updateSuggestionsForCurrent();
      break;
    }
    case 'selection-change': {
      if(lastMode === 'scan') {
        const ns = (els.scanNamespace.value || 'Common').trim();
        pm({ type: 'scan-selection', namespace: ns });
      }
      if(msg.namespaces){ updateNamespaces(msg.namespaces); }
      break;
    }
    case 'namespaces-result': {
      updateNamespaces(msg.namespaces || []);
      break;
    }
  }
};

let lastMode = null;

function updateNamespaces(list){
  detectedNamespaces = Array.isArray(list) ? list : [];
  els.nsListInfo.textContent = detectedNamespaces.length ? 'Namespaces: '+ detectedNamespaces.join(', ') : 'No namespaces found';
}

// Reflect current mode to UI (active state for Scan selection)
function reflectMode(){
  const isScan = lastMode === 'scan';
  els.scanSelection.classList.toggle('active', isScan);
  els.scanSelection.setAttribute('aria-pressed', isScan ? 'true' : 'false');
}

// trigger suggestions by button
els.suggestKeys?.addEventListener('click', async () => {
  await updateSuggestionsForCurrent();
  setStatus('Suggestions updated');
});

// Initial reflect
reflectMode();

// Удалено: ранее использовались дебаунс-обновления текста при вводе
// Теперь текст синхронизируется только на blur, поэтому вспомогательные таймеры не нужны

</script>
</body>
</html>
