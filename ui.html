<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Locize Integration</title>
<style>
  /* Narrow scrollbar */
  ::-webkit-scrollbar { width: 3px; height: 3px; background: transparent; }
  ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 1.5px; }
  ::-webkit-scrollbar-thumb:hover { background: #999; }
  ::-webkit-scrollbar-track { background: transparent; border-radius: 1.5px; }
  /* Base styles */
  body { font: 12px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin: 12px; }
  h2 { margin: 8px 0 4px; font-size: 14px; }
  fieldset { border: 1px solid #ccc; padding: 8px 10px 10px; margin-bottom: 10px; }
  legend { padding: 0 4px; font-weight: 600; }
  label { display: flex; flex-direction: column; font-size: 11px; gap: 2px; }
  input[type=text], input[type=password], select { padding: 4px 6px; font-size: 12px; }
  input.key-input { width: 220px; }
  table { border-collapse: collapse; width: 100%; font-size: 11px; }
  th, td { border: 1px solid #ddd; padding: 4px 6px; vertical-align: top; }
  th { background: #f5f5f5; position: sticky; top: 0; }
  /* keep old statuses for sync coloring */
  tbody tr.synced td { background: #f0fff4; }
  tbody tr.unsynced td { background: #fff7f7; }
  .actions { display: flex; gap: 8px; flex-wrap: wrap; }
  button { cursor: pointer; padding: 4px 12px; font-size: 12px; }
  .row-flex { display: flex; gap: 8px; }
  .small { font-size: 10px; color: #666; }
  .status { margin-top: 6px; min-height: 16px; font-size: 11px; white-space: pre-line; }
  .lang-badge { background:#eee; padding:2px 6px; border-radius:10px; font-size:10px; margin-right:4px; display:inline-block; }
  .flex { display: flex; }
  .gap { gap: 8px; }
  .grow { flex: 1; }
  .nowrap { white-space: nowrap; }
  #keys-container { max-height: 600px; overflow: auto; }
  #uploadProgress { width: 100%; height: 4px; background: #eee; margin-top:4px; position: relative; }
  #uploadProgress span { position:absolute; top:0; left:0; height:100%; background:#4a8cff; width:0; transition: width .2s; }
  /* Active mode styling for Scan selection button */
  #scanSelection.active { background: #4a8cff; color: #fff; border-color: #4a8cff; }
  #scanSelection.active:hover { background: #3a74d1; }
</style>
</head>
<body>
  <fieldset>
    <legend>Settings</legend>
    <div class="row-flex" style="align-items:flex-end; flex-wrap:wrap;">
      <label class="grow">Project ID<input id="projectId" type="text" placeholder="project id" /></label>
      <label class="grow">API Key (write)<input id="apiKey" type="password" placeholder="write api key" /></label>
      <label>Version<input id="version" type="text" value="latest" /></label>
      <label>Base Lang<input id="baseLanguage" type="text" value="en" /></label>
      <button id="saveSettings">Save</button>
    </div>
    <div class="small" style="margin-top: 12px;">Data is saved locally in the plugin clientStorage.</div>
  </fieldset>

  <fieldset>
    <legend>Language</legend>
    <div class="row-flex gap" style="align-items:center; flex-wrap:wrap;">
      <label>Language<select id="languageSelect"></select></label>
    </div>
    <div class="small">Namespaces are detected automatically from existing keys. If no keys are assigned, loading is skipped.</div>
    <div class="small" id="nsListInfo" style="margin-top:4px;color:#444;"></div>
  </fieldset>

  <fieldset>
    <legend>Key management</legend>
    <div class="row-flex gap" style="align-items:flex-end; flex-wrap:wrap;">
      <label>Namespace for new keys<input id="scanNamespace" type="text" placeholder="Common" /></label>
      <div class="row-flex" style="align-items:center; gap:6px;">
        <button id="scanSelection">Scan selection</button>
      </div>
      <label style="flex-direction:row; align-items:center; gap:6px; margin:0;">
        <input id="hideUnchecked" type="checkbox" />
        <span>Hide unchecked</span>
      </label>
    </div>
    <div class="small" style="margin: 6px 0;">Keys are generated based on hierarchy and layer/text name.</div>
    <div id="keys-container">
      <table id="keysTable">
        <thead>
          <tr>
            <th><input type="checkbox" id="selectAll" aria-label="Select all" /></th>
            <th>Namespace</th>
            <th>Key</th>
            <th>Text</th>
            <th>Original name</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="actions" style="margin-top:6px;">
      <button id="applyKeys" disabled>Apply keys to nodes</button>
      <button id="uploadKeys" disabled>Upload to locize (base)</button>
      <button id="restoreNames" disabled>Restore names</button>
    </div>
    <div id="uploadProgress"><span></span></div>
  </fieldset>

  <div class="status" id="status"></div>

<script>
const els = {
  projectId: document.getElementById('projectId'),
  apiKey: document.getElementById('apiKey'),
  version: document.getElementById('version'),
  baseLanguage: document.getElementById('baseLanguage'),
  scanNamespace: document.getElementById('scanNamespace'),
  saveSettings: document.getElementById('saveSettings'),
  scanSelection: document.getElementById('scanSelection'),
  applyKeys: document.getElementById('applyKeys'),
  uploadKeys: document.getElementById('uploadKeys'),
  status: document.getElementById('status'),
  tableBody: document.querySelector('#keysTable tbody'),
  selectAll: document.getElementById('selectAll'),
  languageSelect: document.getElementById('languageSelect'),
  uploadProgress: document.querySelector('#uploadProgress span'),
  restoreNames: document.getElementById('restoreNames'),
  nsListInfo: document.getElementById('nsListInfo'),
  hideUnchecked: document.getElementById('hideUnchecked'),
};

let currentItems = []; // {nodeId,name,text,key,namespace,localKey,selected,synced}
let detectedNamespaces = [];
let hideUnchecked = false;

// Track verification sequence and allow cancellation
let verifyController = null; // AbortController | null
let verifySeq = 0;

// Cache of base language dictionaries: { [ns]: Set(flatKeys) }
const remoteCache = {};

function pm(message){ parent.postMessage({ pluginMessage: message }, '*'); }
function setStatus(msg, append=false){ if(!append) els.status.textContent=''; els.status.textContent += msg + '\n'; }

function renderTable(){
  els.tableBody.innerHTML = '';
  const itemsToRender = hideUnchecked ? currentItems.filter(i => i.selected !== false) : currentItems;
  itemsToRender.forEach((item) => {
    if(!item.namespace || !item.localKey){
      const dot = (item.key||'').indexOf('.')
      if(dot>-1){ item.namespace = item.key.slice(0,dot); item.localKey = item.key.slice(dot+1); } else { item.namespace = ''; item.localKey = item.key; }
    }
    const tr = document.createElement('tr');
    tr.className = item.synced === true ? 'synced' : (item.synced === false ? 'unsynced' : '');

    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = item.selected !== false;
    cb.addEventListener('change', () => { item.selected = cb.checked; updateButtons(); pm({ type: 'set-selected', nodeId: item.nodeId, selected: item.selected }); if(hideUnchecked) renderTable(); });
    tdSel.appendChild(cb);

    const tdNs = document.createElement('td');
    const nsInput = document.createElement('input');
    nsInput.type = 'text';
    nsInput.value = item.namespace || '';
    nsInput.style.width = '90px';
    nsInput.addEventListener('input', () => { item.namespace = nsInput.value.trim(); recomputeKey(item); scheduleStatusRefresh(); });
    tdNs.appendChild(nsInput);

    const tdKey = document.createElement('td');
    const keyInput = document.createElement('input');
    keyInput.type = 'text';
    keyInput.value = item.localKey || '';
    keyInput.className = 'key-input';
    keyInput.addEventListener('input', () => { item.localKey = keyInput.value.trim(); recomputeKey(item); scheduleStatusRefresh(); });
    tdKey.appendChild(keyInput);

    const tdText = document.createElement('td');
    tdText.textContent = item.text;

    const tdOrig = document.createElement('td');
    tdOrig.textContent = item.originalName || '';

    const tdStatus = document.createElement('td');
    tdStatus.textContent = item.synced === true ? 'synced' : (item.synced === false ? 'missing' : '—');

    tr.appendChild(tdSel); tr.appendChild(tdNs); tr.appendChild(tdKey); tr.appendChild(tdText); tr.appendChild(tdOrig); tr.appendChild(tdStatus);
    els.tableBody.appendChild(tr);
  });
  updateButtons();
}

function recomputeKey(item){
  const ns = (item.namespace||'').trim();
  const lk = (item.localKey||'').trim();
  item.key = ns ? `${ns}.${lk}` : lk;
}

function updateButtons(){
  const all = currentItems.length > 0 && currentItems.every(i => i.selected !== false);
  const none = currentItems.every(i => i.selected === false);
  els.selectAll.indeterminate = !all && !none;
  els.selectAll.checked = all && !none;

  const anySelected = currentItems.some(i => i.selected !== false);
  els.applyKeys.disabled = !anySelected;
  els.uploadKeys.disabled = !anySelected;
  els.restoreNames.disabled = !currentItems.length;
}

// Flatten dictionary into a set of keys
function flattenKeys(obj){
  const out = new Set();
  const stack = [[obj, '']];
  while(stack.length){
    const [cur, pref] = stack.pop();
    if(cur && typeof cur === 'object'){
      for(const k of Object.keys(cur)){
        const v = cur[k];
        const p = pref ? pref + '.' + k : k;
        if(v && typeof v === 'object') stack.push([v, p]); else out.add(p);
      }
    }
  }
  return out;
}

// New: flatten nested dict to flat map of key -> value
function flattenToMap(obj){
  const out = {};
  const stack = [[obj, '']];
  while(stack.length){
    const [cur, pref] = stack.pop();
    if(cur && typeof cur === 'object' && !Array.isArray(cur)){
      for(const k of Object.keys(cur)){
        const v = cur[k];
        const p = pref ? pref + '.' + k : k;
        if(v && typeof v === 'object' && !Array.isArray(v)) stack.push([v, p]);
        else out[p] = typeof v === 'string' ? v : (v != null ? String(v) : '');
      }
    } else {
      if(pref) out[pref] = typeof cur === 'string' ? cur : (cur != null ? String(cur) : '');
    }
  }
  return out;
}

let statusRefreshTimer = null;
function scheduleStatusRefresh(){
  clearTimeout(statusRefreshTimer);
  statusRefreshTimer = setTimeout(() => refreshSyncStatus(), 400);
}

async function refreshSyncStatus(){
  const s = collectSettings();
  if(!s.projectId || !s.version || !s.baseLanguage){ currentItems.forEach(i=>i.synced=undefined); renderTable(); return; }
  const nsSet = Array.from(new Set(currentItems.map(i => (i.namespace||'').trim()).filter(Boolean)));
  if(!nsSet.length){ currentItems.forEach(i=>i.synced=undefined); renderTable(); return; }
  try {
    const maps = await Promise.all(nsSet.map(async ns => {
      if(remoteCache[ns]) return [ns, remoteCache[ns]];
      const data = await fetchTranslations(s, s.baseLanguage, ns);
      const flat = flattenKeys(data);
      remoteCache[ns] = flat;
      return [ns, flat];
    }));
    const nsToSet = Object.fromEntries(maps);
    currentItems.forEach(item => {
      const ns = (item.namespace||'').trim();
      const lk = (item.localKey||'').trim();
      if(!ns || !lk){ item.synced = undefined; return; }
      const set = nsToSet[ns];
      item.synced = !!(set && set.has(lk));
    });
  } catch(e){
    setStatus('Status check failed: '+ (e && e.message ? e.message : e));
    currentItems.forEach(i=>i.synced=undefined);
  }
  renderTable();
}

// Settings load
pm({ type: 'load-settings' });

els.saveSettings.addEventListener('click', async () => {
  const s = collectSettings();
  if(!validateSettings(s)) { pm({ type:'notify', message:'ProjectId and ApiKey are required' }); return; }
  if(verifyController) { try { verifyController.abort(); } catch(_){} }
  verifyController = new AbortController();
  const seq = ++verifySeq;
  els.saveSettings.disabled = true;
  const ok = await verifyCredentials(s, verifyController.signal, seq);
  if(seq !== verifySeq) { return; }
  els.saveSettings.disabled = false;
  if(ok){
    pm({ type: 'save-settings', settings: s });
    if(!els.scanNamespace.value) els.scanNamespace.value = 'Common';
    fetchLanguagesList();
    pm({ type: 'get-namespaces' });
    scheduleStatusRefresh();
  } else {
    pm({ type:'notify', message:'Invalid Locize credentials' });
  }
});

function collectSettings(){
  return {
    projectId: els.projectId.value.trim(),
    apiKey: els.apiKey.value.trim(),
    version: els.version.value.trim() || 'latest',
    baseLanguage: els.baseLanguage.value.trim() || 'en',
  };
}

els.scanSelection.addEventListener('click', () => {
  if (lastMode === 'scan') {
    lastMode = null;
    reflectMode();
    setStatus('Scan mode off');
    return;
  }
  lastMode = 'scan';
  reflectMode();
  const ns = (els.scanNamespace.value || 'Common').trim();
  pm({ type: 'scan-selection', namespace: ns });
});

els.hideUnchecked.addEventListener('change', () => {
  hideUnchecked = els.hideUnchecked.checked;
  renderTable();
});

els.applyKeys.addEventListener('click', () => {
  const items = currentItems.filter(i => i.selected !== false).map(i => ({ ...i }));
  pm({ type: 'apply-keys', items });
  scheduleStatusRefresh();
});

els.uploadKeys.addEventListener('click', async () => {
  const sel = currentItems.filter(i => i.selected !== false);
  if(!sel.length) return;
  const s = collectSettings();
  if(!validateSettings(s)) return;
  await uploadSelectedKeys(sel, s);
  for(const ns of Object.keys(remoteCache)) delete remoteCache[ns];
  await refreshSyncStatus();
});

els.selectAll.addEventListener('change', () => {
  currentItems.forEach(i => i.selected = els.selectAll.checked);
  pm({ type: 'set-selected-bulk', list: currentItems.map(i => ({ nodeId: i.nodeId, selected: i.selected !== false })) });
  renderTable();
});

els.languageSelect.addEventListener('change', async () => {
  const s = collectSettings(); if(!s.projectId || !s.version){ setStatus('Fill in settings'); return; }
  const lang = els.languageSelect.value; if(!lang) { setStatus('Select a language'); return; }
  if(!detectedNamespaces.length){ setStatus('No saved keys (namespaces list is empty)'); return; }
  setStatus('Loading translations for: '+ detectedNamespaces.join(', '), false);
  const sTime = Date.now();
  for(const ns of detectedNamespaces){
    try {
      setStatus('→ '+ns+' ...', true);
      const translations = await fetchTranslations(s, lang, ns);
      const flatMap = flattenToMap(translations);
      pm({ type: 'apply-language', map: flatMap, namespace: ns });
      setStatus('✓ '+ns, true);
    } catch(e){ setStatus('✗ '+ns+': '+ (e && e.message ? e.message : e), true); }
  }
  setStatus('Done in '+ ((Date.now()-sTime)/1000).toFixed(1)+'s', true);
});

els.restoreNames.addEventListener('click', () => {
  const selected = currentItems.filter(i => i.selected !== false);
  const targets = selected.length ? selected : currentItems;
  pm({ type: 'restore-names', items: targets.map(t => ({ nodeId: t.nodeId })) });
  setStatus('Restoring names...');
});

function validateSettings(s){
  if(!s.projectId || !s.apiKey){ setStatus('ProjectId and ApiKey are required'); return false; }
  return true;
}

async function fetchLanguagesList(){
  const s = collectSettings(); if(!s.projectId) return;
  try {
    const res = await fetch(`https://api.locize.app/languages/${s.projectId}`);
    if(!res.ok) throw new Error('HTTP '+res.status);
    const data = await res.json();
    const langs = Object.keys(data);
    els.languageSelect.innerHTML = langs.map(l => `<option value="${l}">${l}</option>`).join('');
    if(s.baseLanguage && !els.languageSelect.value) els.languageSelect.value = s.baseLanguage;
  } catch(e){ setStatus('Failed to load languages: '+ e.message); }
}

async function fetchTranslations(s, language, namespace){
  const ns = encodeURIComponent(namespace);
  const url = `https://api.locize.app/${s.projectId}/${s.version}/${language}/${ns}`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  return res.json();
}

async function uploadSelectedKeys(items, s){
  const baseLang = s.baseLanguage || 'en';
  // group by namespace
  const byNs = new Map();
  for(const it of items){
    const ns = (it.namespace || 'Common').trim();
    const local = (it.localKey || (it.key||'').replace(/^.*\./,'')).trim();
    if(!ns || !local){ setStatus('Skip item with empty namespace/localKey: '+ (it.key||'?'), true); continue; }
    if(!byNs.has(ns)) byNs.set(ns, []);
    byNs.get(ns).push({ key: local, value: String(it.text ?? '') });
  }
  const totalKeys = Array.from(byNs.values()).reduce((acc, arr) => acc + arr.length, 0);
  if(totalKeys === 0){ setStatus('Nothing to upload'); return; }

  setStatus('Uploading keys (bulk update)...');
  
  for(const [ns, entries] of byNs.entries()){
    setStatus(`Namespace ${ns}: ${entries.length} key(s)` , true);
    // chunk to 1000 keys per request
    for(const chunk of chunkArray(entries, 1000)){
      const payload = {};
      for(const {key, value} of chunk){ payload[key] = value; }
      try {
        const resInfo = await updateTranslationsBatch(s, baseLang, ns, payload);
        const note = resInfo.note ? ` (${resInfo.note})` : '';
        setStatus(`✓ ${ns}: +${chunk.length} translations${note}`, true);
      } catch(e){
        setStatus(`✗ ${ns}: ${e && e.message ? e.message : e}`, true);
      }
    }
  }
  setStatus(`Done. Uploaded.`, true);
}

function chunkArray(arr, size){
  const out = [];
  for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i, i+size));
  return out;
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function fetchWithAuth(url, options, apiKey){
  // Prefer Bearer as in docs, fallback to raw on 401/403
  let res = await fetch(url, { ...options, headers: { ...(options.headers||{}), Authorization: `Bearer ${apiKey}` } });
  if ((res.status === 401 || res.status === 403) && !String(apiKey||'').startsWith('Bearer ')){
    res = await fetch(url, { ...options, headers: { ...(options.headers||{}), Authorization: apiKey } });
  }
  return res;
}

async function updateTranslationsBatch(s, language, namespace, body){
  const ns = encodeURIComponent(namespace || 'Common');
  const url = `https://api.locize.app/update/${s.projectId}/${s.version}/${language}/${ns}`;
  const opts = {
    method: 'POST',
    headers: { 'Content-Type':'application/json', 'Accept':'application/json' },
    body: JSON.stringify(body)
  };

  // retry on 429 with small backoff
  const maxRetries = 2;
  for(let attempt=0; attempt<=maxRetries; attempt++){
    const res = await fetchWithAuth(url, opts, s.apiKey);
    if(res.status === 429 && attempt < maxRetries){
      await sleep(250 * (attempt+1));
      continue;
    }
    if(res.status === 412){
      // nothing changed, treat as success
      return { ok: true, note: 'no changes' };
    }
    if(!res.ok){
      let extra = '';
      try { extra = await res.text(); } catch(_) {}
      throw new Error(`HTTP ${res.status}${extra ? ': '+extra : ''}`);
    }
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) {
      try { return await res.json(); } catch(_) { return { ok: true }; }
    }
    return { ok: true };
  }
}

function isObjectEmpty(obj){
  if(!obj || typeof obj !== 'object') return true;
  return Object.keys(obj).length === 0;
}

async function verifyCredentials(s, signal, seq){
  // Basic validation already done before
  const isCurrent = () => seq === verifySeq;
  if(isCurrent()) setStatus('Verifying credentials...');
  try {
    const res = await fetch(`https://api.locize.app/languages/${s.projectId}`, { signal });
    const json = await res.json();
    if (isObjectEmpty(json)) { if(isCurrent()) setStatus('Project is empty or not found', true); return false; }
    if(res.status === 404){ if(isCurrent()) setStatus('Project not found (404)', true); return false; }
    if(res.status === 401 || res.status === 403){ if(isCurrent()) setStatus('Unauthorized to access project: '+res.status, true); return false; }
    if(!res.ok){ if(isCurrent()) setStatus('Project check failed: HTTP '+res.status, true); return false; }
    if(isCurrent()) setStatus('Credentials verified ✓', true);
    return true;
  } catch(e){ if(signal?.aborted) { return false; } if(isCurrent()) setStatus('Project check failed: '+ (e && e.message ? e.message : e), true); return false; }
}

window.onmessage = (event) => {
  const msg = event.data.pluginMessage;
  if(!msg) return;
  switch(msg.type){
    case 'settings-loaded': {
      const s = msg.settings;
      els.projectId.value = s.projectId || '';
      els.apiKey.value = s.apiKey || '';
      els.version.value = s.version || 'latest';
      els.baseLanguage.value = s.baseLanguage || 'en';
      if(!els.scanNamespace.value) els.scanNamespace.value = 'Common';
      fetchLanguagesList();
      pm({ type: 'get-namespaces' });
      scheduleStatusRefresh();
      break;
    }
    case 'scan-result': {
      if(msg.warning) setStatus(msg.warning);
      currentItems = (msg.items || []).map(it => ({ ...it, selected: it.selected !== false, synced: undefined }));
      renderTable();
      pm({ type: 'get-namespaces' });
      scheduleStatusRefresh();
      break;
    }
    case 'assigned-result': {
      currentItems = (msg.items || []).map(it => ({ ...it, selected: it.selected !== false, synced: undefined }));
      renderTable();
      scheduleStatusRefresh();
      break;
    }
    case 'selection-change': {
      if(lastMode === 'scan') {
        const ns = (els.scanNamespace.value || 'Common').trim();
        pm({ type: 'scan-selection', namespace: ns });
      }
      if(msg.namespaces){ updateNamespaces(msg.namespaces); }
      break;
    }
    case 'namespaces-result': {
      updateNamespaces(msg.namespaces || []);
      break;
    }
  }
};

let lastMode = null;

function updateNamespaces(list){
  detectedNamespaces = Array.isArray(list) ? list : [];
  els.nsListInfo.textContent = detectedNamespaces.length ? 'Namespaces: '+ detectedNamespaces.join(', ') : 'No namespaces found';
}

// Reflect current mode to UI (active state for Scan selection)
function reflectMode(){
  const isScan = lastMode === 'scan';
  els.scanSelection.classList.toggle('active', isScan);
  els.scanSelection.setAttribute('aria-pressed', isScan ? 'true' : 'false');
}

// Initial reflect
reflectMode();
</script>
</body>
</html>
